```python
# demo/modules/navigation_knowledge_graph.py
import streamlit as st
import pandas as pd
import networkx as nx
from pyvis.network import Network
from typing import Dict, List, Tuple, Any
from io import BytesIO, StringIO
import time
from datetime import datetime

from .base import BaseModule
from utils.cache_utils import cache_navigation_info
from Handle_csv.scenario.navigation.basic_info import poi_info as BasePOIInfo
from Handle_csv.scenario.navigation.navigation_info import get_navigation_info
from use_GaoDe_api.geo import get_location_regeo
from use_GaoDe_api.district import get_district

class NavigationKnowledgeGraphModule(BaseModule):
    """导航知识图谱模块，构建用户、地点、导航事件之间的实体关系"""
    
    def __init__(self, **kwargs):
        super().__init__(
            title="导航知识图谱",
            description="构建用户、导航事件、地点、时间的实体关系网络，支持预测性导航",** kwargs
        )
        self.navi_info = None
        self.nav_data = None
        self.graph = None  # 知识图谱网络x对象
        self.entities = {
            "user": set(),         # 用户实体
            "location": set(),     # 地点实体
            "navigation_event": set(),  # 导航事件实体
            "time": set()          # 时间实体
        }
        self.relations = []  # 关系列表 (源实体, 关系类型, 目标实体, 属性)
    
    def _create_user_entity(self, vin: str = "default_user") -> str:
        """创建用户实体"""
        user_id = f"user_{vin}"
        self.entities["user"].add(user_id)
        return user_id
    
    def _create_location_entity(self, loc_info: Dict[str, str]) -> str:
        """创建地点实体，包含经纬度、地址、行政区划等属性"""
        loc_id = f"loc_{loc_info['poi_location'].replace(',', '_')}"
        if loc_id not in self.entities["location"]:
            self.entities["location"].add(loc_id)
        return loc_id
    
    def _create_time_entity(self, time_str: str) -> str:
        """创建时间实体，包含日期、小时等属性"""
        try:
            dt = datetime.fromisoformat(time_str.split('.')[0])  # 处理毫秒
            time_id = f"time_{dt.strftime('%Y%m%d_%H%M%S')}"
            self.entities["time"].add(time_id)
            return time_id, dt
        except Exception as e:
            self.logger.warning(f"时间格式解析错误: {time_str}, 错误: {str(e)}")
            return f"time_invalid_{hash(time_str)}", None
    
    def _create_navigation_event_entity(self, event_id: int, poi_item: Dict[str, Any]) -> str:
        """创建导航事件实体，包含距离、时长等属性"""
        event_uid = f"event_{event_id}"
        self.entities["navigation_event"].add(event_uid)
        
        # 计算导航距离和时间（调用现有工具函数）
        try:
            poi_obj = BasePOIInfo(poi_item)
            distance = poi_obj.get_driving_distance()
            duration = poi_obj.get_driving_time()
            admin_div = poi_obj.get_administrative_division()
        except Exception as e:
            self.logger.error(f"计算导航属性失败: {str(e)}")
            distance = 0
            duration = 0
            admin_div = {"start": "未知", "end": "未知"}
        
        # 添加事件属性
        return event_uid, {
            "distance_m": round(distance, 2),
            "duration_min": round(duration, 2),
            "start_admin": admin_div["start_administrative_division"],
            "end_admin": admin_div["end_administrative_division"],
            "poi_type": poi_item["type"]
        }
    
    def _build_entities_and_relations(self) -> None:
        """构建知识图谱的实体和关系"""
        if not self.nav_data:
            return
            
        # 创建用户实体
        user_id = self._create_user_entity(vin=self.navi_info.vin if hasattr(self.navi_info, 'vin') else "default")
        
        # 遍历所有导航记录
        for event_idx, poi_item in enumerate(self.nav_data):
            # 1. 创建导航事件实体
            event_uid, event_attrs = self._create_navigation_event_entity(event_idx, poi_item)
            
            # 2. 创建起点和终点实体
            start_loc_id = self._create_location_entity({
                "poi": f"起点_{event_idx}",
                "poi_location": poi_item["start_location"]
            })
            end_loc_id = self._create_location_entity(poi_item)
            
            # 3. 创建时间实体
            start_time_id, start_dt = self._create_time_entity(poi_item["start_time"])
            end_time_id, end_dt = self._create_time_entity(poi_item["end_time"])
            
            # 4. 构建关系
            # 用户-导航事件关系
            self.relations.append((
                user_id, 
                "发起导航", 
                event_uid, 
                {"事件ID": event_idx}
            ))
            
            # 导航事件-起点关系
            self.relations.append((
                event_uid, 
                "从...出发", 
                start_loc_id, 
                {"地址": get_location_regeo(poi_item["start_location"])}
            ))
            
            # 导航事件-终点关系
            self.relations.append((
                event_uid, 
                "到达...", 
                end_loc_id, 
                {
                    "地址": get_location_regeo(poi_item["poi_location"]),
                    "地点类型": poi_item["type"],
                    "名称": poi_item["poi"]
                }
            ))
            
            # 导航事件-开始时间关系
            self.relations.append((
                event_uid, 
                "开始于", 
                start_time_id, 
                {"时间": poi_item["start_time"]}
            ))
            
            # 导航事件-结束时间关系
            self.relations.append((
                event_uid, 
                "结束于", 
                end_time_id, 
                {"时间": poi_item["end_time"]}
            ))
            
            # 时间-时间属性关系（用于时间模式分析）
            if start_dt:
                self.relations.append((
                    start_time_id, 
                    "属于日期", 
                    f"date_{start_dt.strftime('%Y%m%d')}", 
                    {"星期": start_dt.weekday() + 1}
                ))
                self.relations.append((
                    start_time_id, 
                    "属于小时段", 
                    f"hour_{start_dt.hour}", 
                    {"时段类型": "早高峰" if 7<=start_dt.hour<=9 else 
                                  "晚高峰" if 17<=start_dt.hour<=19 else "平峰"}
                ))
    
    def _build_graph(self) -> None:
        """构建NetworkX图对象"""
        self.graph = nx.DiGraph()
        
        # 添加实体节点
        for entity_type, entities in self.entities.items():
            for entity_id in entities:
                self.graph.add_node(
                    entity_id, 
                    type=entity_type,
                    label=entity_id.split('_')[-1]  # 简化显示标签
                )
        
        # 添加关系边
        for src, rel, dst, attrs in self.relations:
            self.graph.add_edge(src, dst, label=rel, **attrs)
    
    def process_data(self) -> None:
        """处理数据并构建知识图谱"""
        if self.data is None:
            self.graph = None
            return
            
        try:
            start_time = time.time()
            # 获取导航信息（复用现有缓存和处理逻辑）
            self.navi_info = cache_navigation_info(self.data)
            self.nav_data = self.navi_info.Get_json_info()['poi_info_list']
            
            # 构建实体和关系
            self._build_entities_and_relations()
            self._build_graph()
            
            end_time = time.time()
            self.logger.info(f"知识图谱构建完成，耗时: {end_time - start_time:.2f}秒")
            self.logger.info(f"实体统计: 用户{len(self.entities['user'])}个, 地点{len(self.entities['location'])}个, "
                            f"事件{len(self.entities['navigation_event'])}个, 时间{len(self.entities['time'])}个")
            
        except KeyError as e:
            error_msg = f"数据格式错误，缺少关键字段: {str(e)}"
            st.error(error_msg)
            self.logger.error(error_msg, exc_info=True)
            self.graph = None
        except Exception as e:
            error_msg = f"构建知识图谱时出错: {str(e)}"
            st.error(error_msg)
            self.logger.error(error_msg, exc_info=True)
            self.graph = None
    
    def _generate_graph_visualization(self) -> BytesIO:
        """生成交互式知识图谱可视化"""
        if not self.graph:
            return None
            
        net = Network(
            height="600px", 
            width="100%", 
            bgcolor="#f8f9fa", 
            font_color="#333",
            directed=True
        )
        
        # 节点样式配置
        node_styles = {
            "user": {"color": "#4285f4", "size": 30},
            "location": {"color": "#34a853", "size": 25},
            "navigation_event": {"color": "#fbbc05", "size": 20},
            "time": {"color": "#ea4335", "size": 20}
        }
        
        # 添加节点
        for node in self.graph.nodes(data=True):
            node_id, node_data = node
            node_type = node_data["type"]
            net.add_node(
                node_id,
                label=node_data["label"],
                color=node_styles[node_type]["color"],
                size=node_styles[node_type]["size"],
                title=f"{node_type}: {node_data['label']}"  # 悬停提示
            )
        
        # 添加边
        for edge in self.graph.edges(data=True):
            src, dst, edge_data = edge
            net.add_edge(
                src, 
                dst, 
                label=edge_data["label"],
                title=str({k: v for k, v in edge_data.items() if k != "label"})  # 显示关系属性
            )
        
        # 布局配置
        net.set_options("""
        var options = {
            "layout": {
                "hierarchical": {
                    "enabled": false,
                    "levelSeparation": 200
                }
            },
            "edges": {
                "smooth": {
                    "type": "cubicBezier",
                    "forceDirection": "horizontal"
                }
            },
            "interaction": {
                "hover": true,
                "tooltipDelay": 200
            }
        }
        """)
        
        # 保存到缓冲区
        buf = StringIO()
        net.write_html(buf)
        buf.seek(0)
        return BytesIO(buf.getvalue().encode())
    
    def _show_prediction_analysis(self) -> None:
        """展示基于知识图谱的预测性导航分析"""
        if not self.nav_data or not self.graph:
            return
            
        st.subheader("预测性导航分析")
        
        # 1. 高频目的地分析（基于地点实体出现频率）
        loc_counts = {}
        for _, _, dst, attrs in self.relations:
            if any(dst.startswith(f"loc_{loc}") for loc in loc_counts) and "名称" in attrs:
                loc_name = attrs["名称"]
                loc_counts[loc_name] = loc_counts.get(loc_name, 0) + 1
        
        if loc_counts:
            top_locations = sorted(loc_counts.items(), key=lambda x: x[1], reverse=True)[:3]
            st.write("高频目的地预测（可能的下一个目的地）:")
            for loc, count in top_locations:
                st.write(f"- {loc}（历史访问{count}次）")
        
        # 2. 时间模式分析（基于时间-事件关系）
        time_patterns = {}
        for src, rel, dst, _ in self.relations:
            if rel == "开始于" and dst.startswith("time_"):
                hour = dst.split('_')[1][8:10]  # 从time_20231001_083000提取小时
                time_patterns[hour] = time_patterns.get(hour, 0) + 1
        
        if time_patterns:
            peak_hour = max(time_patterns.items(), key=lambda x: x[1])[0]
            st.write(f"\n出行高峰时段: {peak_hour}:00，建议避开该时段或提前规划路线")
    
    def render_output(self) -> None:
        """渲染知识图谱和分析结果"""
        if not self.graph:
            st.info("请先上传包含导航信息的CSV文件以构建知识图谱")
            return
        
        # 知识图谱可视化
        st.subheader("导航知识图谱可视化")
        graph_html = self._generate_graph_visualization()
        if graph_html:
            st.components.v1.html(graph_html.getvalue().decode(), height=600)
        
        # 实体关系统计
        col1, col2, col3, col4 = st.columns(4)
        with col1:
            st.metric("用户实体数", len(self.entities["user"]))
        with col2:
            st.metric("地点实体数", len(self.entities["location"]))
        with col3:
            st.metric("导航事件数", len(self.entities["navigation_event"]))
        with col4:
            st.metric("时间实体数", len(self.entities["time"]))
        
        # 预测性分析
        self._show_prediction_analysis()
        
        # 知识图谱应用说明
        st.caption("""
        知识图谱应用场景:
        - 预测性导航：基于历史地点访问频率和时间模式，提前推荐目的地
        - 智能提醒：结合高峰时段和路线距离，提醒用户合理规划出发时间
        - 个性化路线：根据用户常去地点类型，优先推荐匹配兴趣点的路线
        """)
```

### 模块集成方法
在 `demo/app.py` 中添加该模块的集成：

```python
# 在导入部分添加
from modules.navigation_knowledge_graph import NavigationKnowledgeGraphModule

# 在 DashboardApp 的 _initialize_modules 方法中添加
def _initialize_modules(self) -> None:
    self.modules = [
        NavigationVisualizationModule(width=100),
        NavigationMapModule(width=100),
        NavigationKnowledgeGraphModule(width=100)  # 新增知识图谱模块
    ]
```

### 模块特点说明
1. **实体设计**：包含用户、地点、导航事件、时间四大核心实体，覆盖导航场景关键要素
2. **关系网络**：定义了"发起导航"、"从...出发"、"到达..."等9种核心关系，完整描述实体间关联
3. **属性增强**：
   - 地点实体关联高德API获取详细地址和行政区划
   - 导航事件包含距离、时长等计算属性（复用`basic_info.py`中的工具函数）
   - 时间实体包含日期、时段等模式属性
4. **预测能力**：基于知识图谱分析高频目的地和出行高峰，支持预测性导航
5. **可视化**：使用pyvis生成交互式图谱，支持节点hover查看属性和关系详情
6. **兼容性**：复用现有`cache_navigation_info`等缓存机制，与其他模块数据处理逻辑保持一致

该模块可直接用于智能导航提醒功能开发，例如根据历史模式在工作日早高峰前提醒用户前往高频工作地点，或根据目的地类型推荐周边兴趣点。